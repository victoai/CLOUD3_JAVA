import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class Dijkstra {

    // 노드의 개수를 나타내는 상수
    private static final int V = 9;

    // 그래프의 한 간선을 나타내는 클래스
    static class Edge {
        int dest; // 목적지 노드
        int weight; // 간선의 가중치

        Edge(int dest, int weight) {
            this.dest = dest;
            this.weight = weight;
        }
    }

    // 인접 리스트를 사용한 그래프
    List<List<Edge>> graph = new ArrayList<>();

    // 생성자에서 그래프 초기화
    public Dijkstra() {
        for (int i = 0; i < V; i++) {
            graph.add(new ArrayList<>());
        }
    }

    // 간선 추가 함수
    public void addEdge(int src, int dest, int weight) {
        graph.get(src).add(new Edge(dest, weight));
        // 만약 무방향 그래프라면 다음 줄도 추가
        // graph.get(dest).add(new Edge(src, weight));
    }

    // 최단 거리 배열에서 아직 방문하지 않은 노드 중 최소 거리를 갖는 노드를 찾는 함수
    int minDistance(int dist[], boolean visited[]) {
        int min = Integer.MAX_VALUE, minIndex = -1;

        for (int v = 0; v < V; v++) {
            if (!visited[v] && dist[v] <= min) {
                min = dist[v];
                minIndex = v;
            }
        }

        return minIndex;
    }

    // 다익스트라 알고리즘 구현
    public void dijkstra(int src) {
        int dist[] = new int[V]; // 최단 거리 배열
        boolean visited[] = new boolean[V]; // 방문한 노드 표시

        // 초기화: 모든 거리를 무한대로, 방문 표시를 false로 설정
        Arrays.fill(dist, Integer.MAX_VALUE);
        Arrays.fill(visited, false);

        // 시작 노드까지의 거리는 0으로 설정
        dist[src] = 0;

        for (int count = 0; count < V - 1; count++) {
            // 아직 방문하지 않은 노드 중 최단 거리의 노드를 선택
            int u = minDistance(dist, visited);

            // 선택한 노드를 방문 표시
            visited[u] = true;

            // 선택된 노드의 인접 노드에 대해 거리 업데이트
            for (Edge edge : graph.get(u)) {
                int v = edge.dest;
                int weight = edge.weight;
                if (!visited[v] && dist[u] != Integer.MAX_VALUE && dist[u] + weight < dist[v]) {
                    dist[v] = dist[u] + weight;
                }
            }
        }

        // 최단 거리 결과 출력
        printSolution(dist);
    }

    // 결과 출력 함수
    void printSolution(int dist[]) {
        System.out.println("Node \t Distance from Source");
        for (int i = 0; i < V; i++)
            System.out.println(i + " \t\t " + dist[i]);
    }

    public static void main(String[] args) {
        Dijkstra dijkstra = new Dijkstra();
        // 예제 그래프에 간선 추가
        dijkstra.addEdge(0, 1, 4);
        dijkstra.addEdge(0, 7, 8);
        dijkstra.addEdge(1, 2, 8);
        dijkstra.addEdge(1, 7, 11);
        dijkstra.addEdge(2, 3, 7);
        dijkstra.addEdge(2, 8, 2);
        dijkstra.addEdge(2, 5, 4);
        dijkstra.addEdge(3, 4, 9);
        dijkstra.addEdge(3, 5, 14);
        dijkstra.addEdge(4, 5, 10);
        dijkstra.addEdge(5, 6, 2);
        dijkstra.addEdge(6, 7, 1);
        dijkstra.addEdge(6, 8, 6);
        dijkstra.addEdge(7, 8, 7);

        dijkstra.dijkstra(0); // 노드 0에서 시작하는 다익스트라 알고리즘 실행
    }
}
