자바에서의 메서드 호출과 메서드 정보 관리
자바는 강력한 객체 지향 언어로, 메서드 호출은 클래스의 설계와 객체의 상태를 기반으로 이루어집니다. 객체가 메서드 
정보를 어떻게 유지하고
 있는지는 가상 메서드 테이블(Virtual Method Table, VMT) 또는 vtable이라는 개념을 통해 설명할 수 있습니다.

클래스와 메서드 정보
클래스 파일: 자바 클래스는 컴파일된 바이트코드 형태로 .class 파일에 저장됩니다. 이 파일에는 클래스의 메타데이터, 
즉 클래스의 필드, 메서드, 상속 관계 등과 같은 정보가 포함되어 있습니다.

런타임 시 메타데이터: 자바 가상 머신(JVM)은 클래스를 로드할 때 이 메타데이터를 메모리에 유지합니다. 
이 정보에는 메서드의 이름, 리턴 타입, 매개변수 타입, 접근 제어자 등이 포함됩니다.

가상 메서드 테이블 (vtable)
정적 메서드 vs 인스턴스 메서드:

정적 메서드는 클래스 자체에 속하므로, 객체와 무관하게 호출됩니다. 이 메서드들은 클래스 로딩 시점에 vtable에 정적으로 배치됩니다.
인스턴스 메서드는 객체에 속하며, 객체 생성 시점에 해당 객체의 클래스 타입에 따라 올바른 메서드가 vtable에 연결됩니다.
vtable의 역할:

vtable은 클래스의 각 인스턴스가 가지고 있는 메서드 포인터들의 배열입니다. 이 배열은 클래스 계층 구조에서 메서드 호출 시
 적절한 메서드를 호출할 수 있도록 도와줍니다.
각 클래스는 자신의 vtable을 가지고 있으며, vtable에는 해당 클래스에서 사용 가능한 메서드들의 주소가 저장되어 있습니다. 
상속을 통해 메서드가 오버라이드되면,
 해당 메서드의 포인터는 자식 클래스의 vtable에서 부모 클래스의 메서드 포인터를 덮어씁니다.
메서드 호출 과정:

객체에서 메서드를 호출하면 JVM은 해당 객체의 클래스 타입을 확인하고, vtable을 통해 올바른 메서드를 찾습니다.
이 방식은 특히 다형성을 지원하는 데 유용합니다. 예를 들어, 상위 클래스 타입의 변수로 자식 클래스의 인스턴스를 참조할 때,
 해당 인스턴스의 실제 타입에 따라 적절한 메서드가 호출됩니다.
결론
따라서, 자바에서 메서드 호출 시 메서드 정보를 유지하고 사용하는 방식은 JVM의 클래스 로딩 메커니즘과 vtable 구조에 의해 
관리됩니다. 이는 객체가 어떤 메서드를 호출해야 하는지
 결정할 때 런타임에 동적으로 결정을 내릴 수 있게 해주며, 자바의 다형성과 같은 강력한 객체 지향 기능을 가능하게 합니다.


객체 생성 및 vtable 설정

객체가 생성될 때, 해당 객체의 클래스 타입에 따라 적절한 vtable이 설정됩니다. vtable은 클래스의 가상 함수에 대한 포인터를 포함하는 테이블입니다.
메서드 호출 시 vtable 참조

메서드를 호출할 때, 객체의 vtable을 참조하여 호출할 실제 함수 주소를 결정합니다. 이는 런타임에 결정되며, 동적 바인딩(dynamic binding) 또는
 지연 바인딩(late binding)이라고도 합니다.
vtable의 역할

가상 함수 호출: vtable은 객체가 가상 함수 호출 시, 호출해야 할 함수의 정확한 주소를 제공합니다. 이를 통해 올바른 함수가 호출되도록 합니다.
다형성 지원: 상속 관계에서 상위 클래스의 포인터나 참조를 통해 하위 클래스의 메서드를 호출할 수 있게 해줍니다.
 이는 다형성을 지원하는 핵심 메커니즘입니다.
vtable의 동작 과정 예제
클래스 정의

cpp
코드 복사
class Base {
public:
    virtual void foo() { std::cout << "Base foo" << std::endl; }
};

class Derived : public Base {
public:
    void foo() override { std::cout << "Derived foo" << std::endl; }
};
객체 생성

cpp
코드 복사
Base* b = new Derived();
이 때, Derived 클래스의 vtable이 생성되고, foo 함수의 주소가 이 테이블에 등록됩니다.

메서드 호출

cpp
코드 복사
b->foo();
b는 Base 타입의 포인터지만 실제로는 Derived 객체를 가리킵니다.
b->foo() 호출 시, b의 vtable을 참조하여 Derived 클래스의 foo 함수가 호출됩니다.
주의할 점
vtable 크기와 오버헤드: 각 클래스에 대해 vtable이 생성되며, 이는 메모리 사용량에 영향을 미칩니다.
 특히 많은 가상 함수와 상속 계층이 있는 경우 오버헤드가 커질 수 있습니다.
정적 메서드 호출: 정적 메서드는 vtable을 사용하지 않습니다. 정적 메서드는 클래스와 관련된 메서드로, 객체와 관계없이 호출할 수 있습니다.
복잡성: 다형성 구현으로 인해 메서드 호출이 추가적인 레벨의 간접 호출을 포함할 수 있으며, 이는 성능에 영향을 줄 수 있습니다.
따라서, 가상 함수 호출 시에는 반드시 vtable을 통해 올바른 함수 주소를 확인하여 호출하는 것이 맞습니다.
 이는 C++과 같은 객체 지향 언어에서 다형성을 구현하는 핵심적인 부분입니다.





